<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>D3 Test</title>
	<script src="d3/d3.min.js"></script>
	<script src="https://d3js.org/topojson.v1.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		body {
			background-color: #eee;
		}

		svg {
			position: absolute;
			width: 100%;
			height: 100%;
		}

		.background {
			fill: #eee;
			pointer-events: all;
		}

		#zones {
			fill: #555;
		}

		#zones .active {
			fill: #55a;
		}

		#zone-borders {
		  fill: none;
		  stroke: #fff;
		  stroke-width: 1px;
		  stroke-linejoin: round;
		  stroke-linecap: round;
		  pointer-events: none;
	    }

		#ids {
			fill: #fff;
			font-family: helvetica;
			font-size: 10px;
			text-anchor: middle;
			opacity: .75;
		}

		#moused-zone {
			fill: #5a5;
		}
	</style>
</head>
<body>
	<script>
		//set up variables and functions we will need
		var width = window.innerWidth,
			height = window.innerHeight,
			centered;	//for clicked func later. see if already zoomed

		var projectionFunc = d3.geo.mercator()	//world
			.scale(5000)
			.center([-119.6, 36.3])	//hnx coords
			.translate([width/2, height/2]);

		var pathFunc = d3.geo.path()
			.projection(projectionFunc);

		//using d3.behavior.zoom
		var zoom = d3.behavior.zoom()
			.translate([0,0])
			.scale(1)
			.on("zoom", redraw);

		var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height);

		svg.append("rect")
			.attr("class", "background")
		    .attr("width", width)
		    .attr("height", height);

		var g = svg.append("g");

		//get hnx map data and plot it
		d3.json("hnxSaZones.json", function(error, hnx) {
			if (error) throw error;

			var zones = topojson.feature(hnx, hnx.objects.hnxsaZones).features;
			g.selectAll("path")
					.data(zones)
				.enter()
					.append("path")
					.attr("id", "zones")
					.attr("d", pathFunc);

			//make borders separately so they dont slow it down
			g.append("path")
		        .datum(topojson.mesh(hnx, hnx.objects.hnxsaZones, function(a, b) {
				    return a !== b;
			    }))
		        .attr("id", "zone-borders")
		        .attr("d", pathFunc);

			//label zones
			g.selectAll("text")
				.data(zones)
			  .enter().append("text")
			  	.attr("id", "ids")
				.attr("x", function(d) {
					return projectionFunc([d.properties.LON, d.properties.LAT])[0];
				})
				.attr("y", function(d) {
					return projectionFunc([d.properties.LON, d.properties.LAT])[1];
				})
				.text(function(d) {
					return d.properties.ZONE;
				});
		});


		//check to see what data categories were selected
		var categories = ["elev", "Temp", "TempC", "Dewp", "Relh",
			"Winds", "SLP", "Altimeter", "Visibility", "TempHi24",
			"TempLo24", "RelhHi24", "RelhLo24", "GustHi24",
			"RawsTemp12", "RawsTemp13", "RawsTemp14", "RawsRelh12",
			"RawsRelh13", "RawsRelh14"]
		var dataUrl = "ba-simple-proxy/ba-simple-proxy.php?url=http://www.wrh.noaa.gov/hnx/JimBGmwXJList.php?extents=34.74,-121.4,38.36,-117.62&mode=native";
		d3.json(dataUrl, function(error, data) {
			if (error) { console.log("There was an error loading the data." + error); }

			// for(var i = 0; i < categories.length; i++) {
			// 	initialize(data.stations, categories[i]);
			// }

			var i = 0;
			cycle(i, data);
			setInterval(function() {
						cycle(i, data);
						i++;
					}, 2*dt);
		});

		function initialize(dataFull, name) {
			//make a scale
			var colorScale = d3.scale.linear()
				.domain([d3.min(dataFull, function(d) {
					return +( eval("d." + name) );
					}), d3.max(dataFull, function(d) {
						return +( eval("d." + name) );
				 	})]) //+ makes it an int, eval makes string a var
				.range([0, 255]);
			//add data vis with class 'name' and opacity 0
			g.selectAll("circle." + name)
					.data(dataFull)
				.enter()
					.append("circle")
					.attr("class", function(d) {
						if (eval("d." + name)) {
							return name;
						} else {
							return "undefined";
						}
					});

			g.selectAll("circle.undefined")
					.remove();

			g.selectAll("circle." + name)
					.attr("cx", function(d) {
						return projectionFunc([d.longitude, d.latitude])[0]
					})
					.attr("cy", function(d) {
						return projectionFunc([d.longitude, d.latitude])[1]
					})
					.attr("r", 6)
					.attr("fill", function(d) {
						var num = Math.round(colorScale(eval("d." + name)));
						return "rgb(" + num + ", 0, 0)";
					})
					.style("opacity", 0);
		}

		var dt = 5000;
		function cycle(index, dataFull) {
			//pick next data category
			var category = categories[index % categories.length];

			initialize(dataFull, category);

			//change its opacity in a transition to 1 then back to 0
			g.selectAll("circle." + category)
				.transition()
					.duration(dt)
					.style("opacity", 1)
				.transition()
					.delay(dt)
					.duration(dt)
					.style("opacity", 0)
					.remove();

		}

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////

		//this function is for zooming on click
		function clicked(d) {
			var x, y, k;

			if (d && centered !== d) {
				var centroid = pathFunc.centroid(d);
				x = centroid[0];
				y = centroid[1];
				k = 3;
				centered = d;
			} else {
				x = width / 2;
				y = height / 2;
				k = 1;
				centered = null;
			}

			g.selectAll("path")
				//set the class to active if it is the centered one
				.classed("active", centered && function(d) {
					return d === centered;
				});

			g.transition()
				.duration(750)
			    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")");
		}

		//for when the user mouses over a zones
		function handleMouseOver() {	//adding interactivity
			d3.select(this)
				.attr("id", "moused-zone");
		}
		function handleMouseOut() {	//back to normal
			d3.select(this)
				.attr("id", "zones");
		}

		//zooming and translating
		function redraw() {
	        g.transition().duration(100).ease("linear")
				.attr("transform",
				"translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
		}

		//wtf is this
		d3.select(self.frameElement)
			.style("height", height + "px");

	</script>
</body>
</html>
