<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>D3 Test</title>
	<script src="d3/d3.js"></script>
	<script src="d3/topojson.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		body {
			background-color: #eee;
		}
		svg {
			position: absolute;
			width: 100%;
			height: 100%;
		}
		.background {
			fill: #eee;
			pointer-events: all;
		}
		#zones.active {
			fill: #55a;
		}
		#zones {
			fill: #555;
		}
		#zone-borders {
		  fill: none;
		  stroke: #fff;
		  stroke-width: 1px;
		  stroke-linejoin: round;
		  stroke-linecap: round;
		  pointer-events: none;
	    }
		.category-text {
			font-family: Roboto;
			fill: pink;
			font-size: 36px;
		}

		.min-text, .max-text {
			font-family: Roboto;
			fill: pink;
			font-size: 15px;
		}
	</style>
</head>
<body>
	<script>
		//set up variables and functions we will need
		var width = window.innerWidth;
		var height = window.innerHeight;
		var scale = 9000;

		var projectionFunc = d3.geo.mercator()
			.scale(scale)
			.center([-119.6, 36.3])
			.translate([width/2, height/2]);

		var pathFunc = d3.geo.path()
			.projection(projectionFunc);

		var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height);

		//setup map on bot
		var gMap = svg.append("g")
				.attr("class", "map");

		//setup vis on top
		var gVis = svg.append("g")
				.attr("class", "vis");

		//global vars we'll need
		var zoneNumbers = [];
		var orderedZoneNumbers = [];
		var index = 0;
		var dt = 2000;
		// var debug;

		d3.json("hnxSaZones.json", function(error, hnxJson) {
			if (error) { console.log("there was an error loading the data" + error); }

			//take the data and set up basic map stuff
			var zones = topojson.feature(hnxJson, hnxJson.objects.hnxsaZones).features;
			var borders = topojson.mesh(hnxJson, hnxJson.objects.hnxsaZones, function(a, b) { return a !== b; } );

			//put the zone numbers in order
			zones.sort(function(a, b) { return a.properties.ZONE - b.properties.ZONE; })

			// debug = zones;

			gMap.selectAll("path")
					.data(zones)
				.enter()
					.append("path")
					.attr("id", "zones")
					// .attr("id", function(d) {
					// 	return "zone-" + d.properties.ZONE;
					// })
					.attr("d", pathFunc);

			//make borders separately for better transitions etc
			gMap.append("path")
					.datum(borders)
					.attr("id", "zone-borders")
					.attr("d", pathFunc);

			//now that we have basic map set up, send data to main func
			main(zones);
		});


		//globals:
		var categories = ["elev", "Temp", "TempC", "Dewp", "Relh",
				"Winds", "SLP", "Altimeter", "Visibility", "TempHi24",
				"TempLo24", "RelhHi24", "RelhLo24", "GustHi24",
				"RawsTemp12", "RawsTemp13", "RawsTemp14", "RawsRelh12",
				"RawsRelh13", "RawsRelh14"];
		var timeAtZone = 1000 * categories.length;
		var timePerData = timeAtZone/(categories.length + 2);
		var dataChangeTransition = timePerData/2;


		function main(mapData) {
			//put all the vis on the svg, make the heatmap, cycle through
			//changing opacity on the categories selected (default all)
			//and cycle through each zone

			//get the data and run initialize() for each category
			var dataUrl = "ba-simple-proxy/ba-simple-proxy.php?url=http://www.wrh.noaa.gov/hnx/JimBGmwXJList.php?extents=34.74,-121.4,38.36,-117.62&mode=native";
			d3.json(dataUrl, function(error, data) {
				if (error) { console.log("There was an error loading the data." + error); }

				//debug = data.stations;

				for (var i = 0; i < categories.length; i++) {
					initialize(data.stations, categories[i])
				}

				//now run through functions
				var i = 0;
				var index = 0;
				//to have a delay in animation
				var cycleEnded = false;
				var wasSkipped = false;

				makeLegend();
				cycleMap(mapData, index);

				setInterval(function() {
							index++;
							cycleMap(mapData, index);
						}, timeAtZone);

				setInterval(function() {
							if ( (i % categories.length) == 0) {
								//two possibilities
								if (cycleEnded) {
									//turn off before zone change
									gVis.selectAll("circle")
										.transition()
											.duration(timePerData)
											.style("opacity", 0);
									gVis.selectAll("text")
										.transition()
											.duration(timePerData)
											.style("opacity", 0);
									cycleEnded = false;
								} else {
									//two possibilities
									if (wasSkipped) {
										//start things up again
										cycleData(i);
										i++;
										wasSkipped = false;
									} else {
										//do nothing at beginning
										wasSkipped = true;
									}
								}
							} else {
								if ( (i % categories.length) == (categories.length - 1) ) {
									cycleEnded = true;
								}
								cycleData(i);
								i++;
							}
						}, timePerData);

			});
		}


		function makeLegend() {
			//make a heatmap bar to show what the data represents
			var numRects = 100;
			var rectsData = [];
			for (var i = 0; i < numRects; i++) {
				rectsData.push(i);
			}
			var textHeight = height/15;
			var categoryTextWidth = width/4;
			var colorScale = d3.scale.linear()
					.domain([0, numRects - 1])
					.range([0, 255]);

			gVis.selectAll("rect.heatmap")
					.data(rectsData)
				.enter()
					.append("rect")
					.attr("x", function(d, i) {
						return 2.2*categoryTextWidth + i*(.75*categoryTextWidth/numRects);
					})
					.attr("y", textHeight/2)
					.attr("width", categoryTextWidth/numRects)
					.attr("height", textHeight/2)
					.attr("fill", function(d) {
						var num = Math.round(colorScale(d));
						return "rgb(" + num + ", 0, " + (255 - num) + ")";
					});
		}


		var centered;	//initialize variable for later to see what zone is centered
		function cycleMap(data, index) {
			//this function picks the next zone and centers the map on it

			var zoneData = data[ index % data.length ]

			//get center of next zone
			var centroid = pathFunc.centroid(zoneData);
			var x = -centroid[0];
			var y = -centroid[1];
			var scaleFactor = 3;	//how far to zoom
			centered = zoneData;	//for changing fill

			var translate = projectionFunc.translate();

			projectionFunc
					.translate([translate[0] + x + width / 2, translate[1] + y + height / 2])
					.scale(scale * scaleFactor);

			//change fill and transition to new transform
			gMap.selectAll("path")
					.classed("active", centered && function(d) { return d === centered; })
				.transition()
					.duration(timePerData)
					.attr("d", pathFunc);

			// Transition to the new transform.
			// g.transition()
			// 		.duration(timePerData)
			// 		.attr("transform",
			// 			"translate(" + width/2 + "," + height/2 + ")scale(" + scaleFactor + ")translate(" + x + "," + y + ")"
			// 		);

			//make borders lighter
			gMap.selectAll("#zone-borders")
				.style("stroke-width", 1.5/scaleFactor + "px");

			//put data in right spot
			gVis.selectAll("circle")
					.attr("cx", function(d) {
						return projectionFunc([d.longitude, d.latitude])[0];
					})
					.attr("cy", function(d) {
						return projectionFunc([d.longitude, d.latitude])[1];
					});
		}


		function cycleData(i) {
			//pick next data category, make it opacity 1 and the
			//one before it opacity 0 in a smooth transition

			var nextCategory = categories[i % categories.length];
			var previousCategory = categories[(i-1) % categories.length];

			gVis.selectAll("#" + previousCategory)		//above
				.transition()
					.duration(dataChangeTransition)
					.style("opacity", 0);


			gVis.selectAll("#" + nextCategory)		//below
				.transition()
					.duration(dataChangeTransition)
					.style("opacity", 1);

		}


		function average(data) {
			//returns mean of data
			var sum = 0;
			for (var i = 0; i < data.length; i++) {
				sum += data[i];
			}
			var average = sum/data.length;
			return average;
		}


		function initialize(dataFull, name) {
			//from the data, plot the heatmapped dots in their
			//coordinates and start them off opacity 0.
			//also display some text for what the colors mean
			//and what the data is about
			var dataList = [];
			var newNum;
			for (var i = 0; i < dataFull.length; i++) {
				newNum = eval("dataFull[i]." + name);
				if (typeof newNum == "string" && newNum != "") {
					dataList.push( parseFloat(newNum) );
				}
			}

			var avg = average(dataList);

			var diffs = [];
			for (var i = 0; i < dataList.length; i++) {
				diff = Math.abs(dataList[i] - avg)
				diffs.push( Math.pow(diff, 2) );
			}
			var sum = 0;
			for (var i = 0; i < diffs.length; i++) {
				sum += diffs[i];
			}
			var stdv = Math.sqrt(sum/diffs.length);

			dataList.sort( function(a, b) { return a-b; });

			for (var i = 0; i < dataList.length; i++) {
				if (dataList[i] > (avg - 3*stdv)) {
					var min = dataList[i];
					break;
				}
			}
			for (var i = 0; i < dataList.length; i++) {
				if (dataList[dataList.length - i - 1] < (avg + 3*stdv)) {
					var max = dataList[dataList.length - i - 1];
					break;
				}
			}

			var colorScale = d3.scale.linear()
					.domain([min, max])
					.range([0, 255]);

			// var radiusScale =	d3.scale.linear()
			// 				.domain([min, max])
			// 				.range([2, 10]);

			//add data vis with class 'name' and opacity 0
			var circs = gVis.selectAll("circle." + name)
					.data(dataFull);

			circs
				.enter()
					.append("circle")
					.attr("class", function(d) {
						if (eval("d." + name)) {
							return name;
						} else {
							return "undefined";
						}
					})
					.attr("id", name)
					.attr("cx", function(d) {
						return projectionFunc([d.longitude, d.latitude])[0]
					})
					.attr("cy", function(d) {
						return projectionFunc([d.longitude, d.latitude])[1]
					})
					// .attr("r", function(d) {
					// 	return radiusScale(eval("d." + name));
					// })
					.attr("r", 8)
					.attr("fill", function(d) {
						var num = Math.round(colorScale(eval("d." + name)));
						if (num < 0 || num > 255) {
							return "rgb(0, 0, 0)";
						}
						return "rgb(" + num + ", 0, " + (255 - num)+ ")";
					})
					.style("opacity", 0);

			circs
					.attr("class", function(d) {
						if (eval("d." + name)) {
							return name;
						} else {
							return "undefined";
						}
					})
					.attr("cx", function(d) {
						return projectionFunc([d.longitude, d.latitude])[0]
					})
					.attr("cy", function(d) {
						return projectionFunc([d.longitude, d.latitude])[1]
					})
					// .attr("r", function(d) {
					// 	return radiusScale(eval("d." + name));
					// })
					.attr("fill", function(d) {
						var num = Math.round(colorScale(eval("d." + name)));
						if (num < 0 || num > 255) {
							return "rgb(0, 0, 0)";
						}
						return "rgb(" + num + ", 0, " + (255 - num)+ ")";
					})
					.style("opacity", 0);

			circs
				.exit()
					.remove()

			//the ones that had no data
			gVis.selectAll("circle.undefined")
					.remove();

			//display name of category
			var textHeight = height/15;
			var categoryTextWidth = width/4;
			var text = gVis.selectAll("text#" + name + ".category-text")
					.data([0]);

			text
				.enter()
					.append("text")
					.attr("class", "category-text")
					.attr("id", name)
					.attr("x", categoryTextWidth)
					.attr("y", textHeight)
					.text(name)
					.style("opacity", 0);

			text
					.text(name);

			//show a legend for the color map
			var minText = gVis.selectAll("text#" + name + ".min-text")
					.data([0]);

			minText
				.enter()
					.append("text")
					.attr("class", "min-text")
					.attr("id", name)
					.attr("x", 2*categoryTextWidth)
					.attr("y", textHeight)
					.text(min)
					.style("opacity", 0);

			minText
				.text(min);

			var maxText = gVis.selectAll("text#" + name + ".max-text")
					.data([0]);

			maxText
				.enter()
					.append("text")
					.attr("class", "max-text")
					.attr("id", name)
					.attr("x", 3*categoryTextWidth)
					.attr("y", textHeight)
					.text(max)
					.style("opacity", 0);

			maxText
				.text(max);
		}
	</script>
</body>
</html>
